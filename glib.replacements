convert c:
	#define G_STATIC_ASSERT(expr) \
		typedef char G_PASTE (_GStaticAssertCompileTimeAssertion_, __LINE__)[(expr) ? 1 : -1] G_GNUC_UNUSED
to fb:
	#define G_STATIC_ASSERT(expr) #assert expr

convert c: #define G_STRLOC __FILE__ ":" G_STRINGIFY (__LINE__)
to fb:     #define G_STRLOC __FILE__ ":" G_STRINGIFY(__LINE__)

convert c: #define _G_NEW(struct_type, n_structs, func)      ((struct_type *) g_##func##_n((n_structs), sizeof(struct_type)))
to fb:     #define _G_NEW(struct_type, n_structs, func) cptr(struct_type ptr, g_##func##_n((n_structs), sizeof(struct_type)))

convert c: #define _G_RENEW(struct_type, mem, n_structs, func)      ((struct_type *) g_##func##_n(mem, (n_structs), sizeof(struct_type)))
to fb:     #define _G_RENEW(struct_type, mem, n_structs, func) cptr(struct_type ptr, g_##func##_n(mem, (n_structs), sizeof(struct_type)))

convert c:
	#define G_WIN32_DLLMAIN_FOR_DLL_NAME(static, dll_name) \
		static char *dll_name; \
		BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { \
			wchar_t wcbfr[1000]; \
			char *tem; \
			switch (fdwReason) { \
			case DLL_PROCESS_ATTACH: \
				GetModuleFileNameW((HMODULE)hinstDLL, wcbfr, G_N_ELEMENTS(wcbfr)); \
				tem = g_utf16_to_utf8(wcbfr, -1, NULL, NULL, NULL); \
				dll_name = g_path_get_basename(tem); \
				g_free(tem); \
				break; \
			} \
			return TRUE; \
		}
to fb:
	#macro G_WIN32_DLLMAIN_FOR_DLL_NAME(static, dll_name)
		dim shared dll_name as zstring ptr
		function DllMain stdcall alias "DllMain"(byval hinstDLL as HINSTANCE, byval fdwReason as DWORD, byval lpvReserved as LPVOID) as BOOL
			dim wcbfr as wstring * 1000
			dim tem as zstring ptr
			select case fdwReason
			case DLL_PROCESS_ATTACH
				GetModuleFileNameW(cast(HMODULE, hinstDLL), wcbfr, G_N_ELEMENTS(wcbfr))
				tem = g_utf16_to_utf8(wcbfr, -1, NULL, NULL, NULL)
				dll_name = g_path_get_basename(tem)
				g_free(tem)
			end select
			return TRUE
		end function
	#endmacro

convert c: #define g_error(...) G_STMT_START { g_log(G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, __VA_ARGS__); for (;;) ; } G_STMT_END
to c:      #define g_error(...) g_log(G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, __VA_ARGS__)

convert c: #define g_warn_if_reached() do { g_warn_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, NULL); } while (0)
to c:      #define g_warn_if_reached()      g_warn_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, NULL)

convert c:
	#define g_warn_if_fail(expr) \
		do { \
			if G_LIKELY(expr) \
				; \
			else \
				g_warn_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #expr); \
		} while (0)
to fb:
	#macro g_warn_if_fail(expr)
		scope
			if G_LIKELY(expr) then
			else
				g_warn_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #expr)
			end if
		end scope
	#endmacro

convert c:
	#define g_return_if_fail(expr) \
		G_STMT_START { \
			if G_LIKELY(expr) { \
			} else { \
				g_return_if_fail_warning(G_LOG_DOMAIN, G_STRFUNC, #expr); \
				return; \
			} \
			; \
		} G_STMT_END
to fb:
	#macro g_return_if_fail(expr)
		scope
			if G_LIKELY(expr) then
			else
				g_return_if_fail_warning(G_LOG_DOMAIN, G_STRFUNC, #expr)
				return
			end if
		end scope
	#endmacro

convert c:
	#define g_return_val_if_fail(expr, val) \
		G_STMT_START { \
			if G_LIKELY(expr) { \
			} else { \
				g_return_if_fail_warning(G_LOG_DOMAIN, G_STRFUNC, #expr); \
				return (val); \
			} \
			; \
		} G_STMT_END
to fb:
	#macro g_return_val_if_fail(expr, val)
		scope
			if G_LIKELY(expr) then
			else
				g_return_if_fail_warning(G_LOG_DOMAIN, G_STRFUNC, #expr)
				return (val)
			end if
		end scope
	#endmacro

convert c:
	#define g_return_if_reached() \
		G_STMT_START { \
			g_log(G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", __FILE__, __LINE__, G_STRFUNC); \
			return; \
		} G_STMT_END
to fb:
	#macro g_return_if_reached()
		scope
			g_log(G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", __FILE__, __LINE__, G_STRFUNC)
			return
		end scope
	#endmacro

convert c:
	#define g_return_val_if_reached(val) \
		G_STMT_START { \
			g_log(G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", __FILE__, __LINE__, G_STRFUNC); \
			return (val); \
		} G_STMT_END
to fb:
	#macro g_return_val_if_reached(val)
		scope
			g_log(G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", __FILE__, __LINE__, G_STRFUNC)
			return (val)
		end scope
	#endmacro

convert c: #define g_scanner_add_symbol(scanner, symbol, value) G_STMT_START { g_scanner_scope_add_symbol ((scanner), 0, (symbol), (value));} G_STMT_END
to c:      #define g_scanner_add_symbol(scanner, symbol, value) g_scanner_scope_add_symbol((scanner), 0, (symbol), (value))

convert c: #define g_scanner_remove_symbol(scanner, symbol) G_STMT_START { g_scanner_scope_remove_symbol ((scanner), 0, (symbol));} G_STMT_END
to c:      #define g_scanner_remove_symbol(scanner, symbol) g_scanner_scope_remove_symbol((scanner), 0, (symbol))

convert c: #define g_scanner_foreach_symbol(scanner, func, data) G_STMT_START { g_scanner_scope_foreach_symbol ((scanner), 0, (func), (data));} G_STMT_END
to c:      #define g_scanner_foreach_symbol(scanner, func, data) g_scanner_scope_foreach_symbol((scanner), 0, (func), (data))

convert c: #define g_slice_dup(type, mem) (1 ? (type*) g_slice_copy(sizeof(type), (mem)) : ((void) ((type*) 0 == (mem)), (type*) 0))
to c:      #define g_slice_dup(type, mem)     ((type*) g_slice_copy(sizeof(type), (mem)))

convert c: #define g_slice_free(type, mem) G_STMT_START { if (1) g_slice_free1(sizeof(type), (mem)); else (void) ((type*) 0 == (mem));} G_STMT_END
to c:      #define g_slice_free(type, mem)                       g_slice_free1(sizeof(type), (mem))

convert c: #define g_slice_free_chain(type, mem_chain, next) G_STMT_START { if (1) g_slice_free_chain_with_offset(sizeof(type), (mem_chain), G_STRUCT_OFFSET(type, next)); else (void) ((type*) 0 == (mem_chain));} G_STMT_END
to c:      #define g_slice_free_chain(type, mem_chain, next)                       g_slice_free_chain_with_offset(sizeof(type), (mem_chain), G_STRUCT_OFFSET(type, next))
