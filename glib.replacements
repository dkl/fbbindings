convert c:
	#define G_STATIC_ASSERT(expr) \
		typedef char G_PASTE (_GStaticAssertCompileTimeAssertion_, __LINE__)[(expr) ? 1 : -1] G_GNUC_UNUSED
to fb:
	#define G_STATIC_ASSERT(expr) #assert expr

convert c: #define G_STRLOC __FILE__ ":" G_STRINGIFY (__LINE__)
to fb:     #define G_STRLOC __FILE__ ":" G_STRINGIFY(__LINE__)

convert c: #define _G_NEW(struct_type, n_structs, func)      ((struct_type *) g_##func##_n((n_structs), sizeof(struct_type)))
to fb:     #define _G_NEW(struct_type, n_structs, func) cptr(struct_type ptr, g_##func##_n((n_structs), sizeof(struct_type)))

convert c: #define _G_RENEW(struct_type, mem, n_structs, func)      ((struct_type *) g_##func##_n(mem, (n_structs), sizeof(struct_type)))
to fb:     #define _G_RENEW(struct_type, mem, n_structs, func) cptr(struct_type ptr, g_##func##_n(mem, (n_structs), sizeof(struct_type)))

convert c:
	#define G_WIN32_DLLMAIN_FOR_DLL_NAME(static, dll_name) \
		static char *dll_name; \
		BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { \
			wchar_t wcbfr[1000]; \
			char *tem; \
			switch (fdwReason) { \
			case DLL_PROCESS_ATTACH: \
				GetModuleFileNameW((HMODULE)hinstDLL, wcbfr, G_N_ELEMENTS(wcbfr)); \
				tem = g_utf16_to_utf8(wcbfr, -1, NULL, NULL, NULL); \
				dll_name = g_path_get_basename(tem); \
				g_free(tem); \
				break; \
			} \
			return TRUE; \
		}
to fb:
	#macro G_WIN32_DLLMAIN_FOR_DLL_NAME(static, dll_name)
		dim shared dll_name as zstring ptr
		function DllMain stdcall alias "DllMain"(byval hinstDLL as HINSTANCE, byval fdwReason as DWORD, byval lpvReserved as LPVOID) as BOOL
			dim wcbfr as wstring * 1000
			dim tem as zstring ptr
			select case fdwReason
			case DLL_PROCESS_ATTACH
				GetModuleFileNameW(cast(HMODULE, hinstDLL), wcbfr, G_N_ELEMENTS(wcbfr))
				tem = g_utf16_to_utf8(wcbfr, -1, NULL, NULL, NULL)
				dll_name = g_path_get_basename(tem)
				g_free(tem)
			end select
			return TRUE
		end function
	#endmacro

convert c: #define g_error(...) G_STMT_START { g_log(G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, __VA_ARGS__); for (;;) ; } G_STMT_END
to c:      #define g_error(...) g_log(G_LOG_DOMAIN, G_LOG_LEVEL_ERROR, __VA_ARGS__)

convert c: #define g_warn_if_reached() do { g_warn_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, NULL); } while (0)
to c:      #define g_warn_if_reached()      g_warn_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, NULL)

convert c:
	#define g_warn_if_fail(expr) \
		do { \
			if G_LIKELY(expr) \
				; \
			else \
				g_warn_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #expr); \
		} while (0)
to fb:
	#macro g_warn_if_fail(expr)
		scope
			if G_LIKELY(expr) then
			else
				g_warn_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #expr)
			end if
		end scope
	#endmacro

convert c:
	#define g_return_if_fail(expr) \
		G_STMT_START { \
			if G_LIKELY(expr) { \
			} else { \
				g_return_if_fail_warning(G_LOG_DOMAIN, G_STRFUNC, #expr); \
				return; \
			} \
			; \
		} G_STMT_END
to fb:
	#macro g_return_if_fail(expr)
		scope
			if G_LIKELY(expr) then
			else
				g_return_if_fail_warning(G_LOG_DOMAIN, G_STRFUNC, #expr)
				return
			end if
		end scope
	#endmacro

convert c:
	#define g_return_val_if_fail(expr, val) \
		G_STMT_START { \
			if G_LIKELY(expr) { \
			} else { \
				g_return_if_fail_warning(G_LOG_DOMAIN, G_STRFUNC, #expr); \
				return (val); \
			} \
			; \
		} G_STMT_END
to fb:
	#macro g_return_val_if_fail(expr, val)
		scope
			if G_LIKELY(expr) then
			else
				g_return_if_fail_warning(G_LOG_DOMAIN, G_STRFUNC, #expr)
				return (val)
			end if
		end scope
	#endmacro

convert c:
	#define g_return_if_reached() \
		G_STMT_START { \
			g_log(G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", __FILE__, __LINE__, G_STRFUNC); \
			return; \
		} G_STMT_END
to fb:
	#macro g_return_if_reached()
		scope
			g_log(G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", __FILE__, __LINE__, G_STRFUNC)
			return
		end scope
	#endmacro

convert c:
	#define g_return_val_if_reached(val) \
		G_STMT_START { \
			g_log(G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", __FILE__, __LINE__, G_STRFUNC); \
			return (val); \
		} G_STMT_END
to fb:
	#macro g_return_val_if_reached(val)
		scope
			g_log(G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL, "file %s: line %d (%s): should not be reached", __FILE__, __LINE__, G_STRFUNC)
			return (val)
		end scope
	#endmacro

convert c: #define g_scanner_add_symbol(scanner, symbol, value) G_STMT_START { g_scanner_scope_add_symbol ((scanner), 0, (symbol), (value));} G_STMT_END
to c:      #define g_scanner_add_symbol(scanner, symbol, value) g_scanner_scope_add_symbol((scanner), 0, (symbol), (value))

convert c: #define g_scanner_remove_symbol(scanner, symbol) G_STMT_START { g_scanner_scope_remove_symbol ((scanner), 0, (symbol));} G_STMT_END
to c:      #define g_scanner_remove_symbol(scanner, symbol) g_scanner_scope_remove_symbol((scanner), 0, (symbol))

convert c: #define g_scanner_foreach_symbol(scanner, func, data) G_STMT_START { g_scanner_scope_foreach_symbol ((scanner), 0, (func), (data));} G_STMT_END
to c:      #define g_scanner_foreach_symbol(scanner, func, data) g_scanner_scope_foreach_symbol((scanner), 0, (func), (data))

convert c: #define g_slice_dup(type, mem) (1 ? (type*) g_slice_copy(sizeof(type), (mem)) : ((void) ((type*) 0 == (mem)), (type*) 0))
to c:      #define g_slice_dup(type, mem)     ((type*) g_slice_copy(sizeof(type), (mem)))

convert c: #define g_slice_free(type, mem) G_STMT_START { if (1) g_slice_free1(sizeof(type), (mem)); else (void) ((type*) 0 == (mem));} G_STMT_END
to c:      #define g_slice_free(type, mem)                       g_slice_free1(sizeof(type), (mem))

convert c: #define g_slice_free_chain(type, mem_chain, next) G_STMT_START { if (1) g_slice_free_chain_with_offset(sizeof(type), (mem_chain), G_STRUCT_OFFSET(type, next)); else (void) ((type*) 0 == (mem_chain));} G_STMT_END
to c:      #define g_slice_free_chain(type, mem_chain, next)                       g_slice_free_chain_with_offset(sizeof(type), (mem_chain), G_STRUCT_OFFSET(type, next))

convert c:
	#define g_assert_cmpstr(s1, cmp, s2) \
		G_STMT_START { \
			const char *__s1 = (s1), *__s2 = (s2); \
			if (g_strcmp0(__s1, __s2) cmp 0) \
				; \
			else \
				g_assertion_message_cmpstr(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #s1 " " #cmp " " #s2, __s1, #cmp, __s2); \
		} G_STMT_END
to fb:
	#macro g_assert_cmpstr(s1, cmp, s2)
		scope
			dim as const zstring ptr __s1 = (s1), __s2 = (s2)
			if g_strcmp0(__s1, __s2) cmp 0 then
			else
				g_assertion_message_cmpstr(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #s1 " " #cmp " " #s2, __s1, #cmp, __s2)
			end if
		end scope
	#endmacro

convert c:
	#define g_assert_cmpint(n1, cmp, n2) \
		G_STMT_START { \
			gint64 __n1 = (n1), __n2 = (n2); \
			if (__n1 cmp __n2) \
				; \
			else \
				g_assertion_message_cmpnum(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #n1 " " #cmp " " #n2, __n1, #cmp, __n2, 'i'); \
		} G_STMT_END
to fb:
	#macro g_assert_cmpint(n1, cmp, n2)
		scope
			dim as gint64 __n1 = (n1), __n2 = (n2)
			if __n1 cmp __n2 then
			else
				g_assertion_message_cmpnum(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #n1 " " #cmp " " #n2, __n1, #cmp, __n2, 'i')
			end if
		end scope

convert c:
	#define g_assert_cmpuint(n1, cmp, n2) \
		G_STMT_START { \
			guint64 __n1 = (n1), __n2 = (n2); \
			if (__n1 cmp __n2) \
				; \
			else \
				g_assertion_message_cmpnum(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #n1 " " #cmp " " #n2, __n1, #cmp, __n2, 'i'); \
		} G_STMT_END
to fb:
	#macro g_assert_cmpuint(n1, cmp, n2)
		scope
			dim as guint64 __n1 = (n1), __n2 = (n2)
			if __n1 cmp __n2
			else
				g_assertion_message_cmpnum(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #n1 " " #cmp " " #n2, __n1, #cmp, __n2, 'i')
			end if
		end scope
	#endmacro

convert c:
	#define g_assert_cmphex(n1, cmp, n2) \
		G_STMT_START { \
			guint64 __n1 = (n1), __n2 = (n2); \
			if (__n1 cmp __n2) \
				; \
			else \
				g_assertion_message_cmpnum(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #n1 " " #cmp " " #n2, __n1, #cmp, __n2, 'x'); \
		} G_STMT_END
to fb:
	#macro g_assert_cmphex(n1, cmp, n2)
		scope
			dim as guint64 __n1 = (n1), __n2 = (n2)
			if __n1 cmp __n2 then
			else
				g_assertion_message_cmpnum(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #n1 " " #cmp " " #n2, __n1, #cmp, __n2, 'x')
			end if
		end scope
	#endmacro

# This one uses "long double", but I think it can be translated to just "double" just fine
convert c:
	#define g_assert_cmpfloat(n1, cmp, n2) \
		G_STMT_START { \
			long double __n1 = (n1), __n2 = (n2); \
			if (__n1 cmp __n2) \
				; \
			else \
				g_assertion_message_cmpnum(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #n1 " " #cmp " " #n2, __n1, #cmp, __n2, 'f'); \
		} G_STMT_END
to fb:
	#macro g_assert_cmpfloat(n1, cmp, n2)
		scope
			dim as double __n1 = (n1), __n2 = (n2)
			if __n1 cmp __n2 then
			else
				g_assertion_message_cmpnum(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #n1 " " #cmp " " #n2, __n1, #cmp, __n2, 'f')
			end if
		end scope
	#endmacro

convert c:
	#define g_assert_no_error(err) \
		G_STMT_START { \
			if (err) \
				g_assertion_message_error(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #err, err, 0, 0); \
		} G_STMT_END
to fb:
	#macro g_assert_no_error(err)
		scope
			if err then
				g_assertion_message_error(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #err, err, 0, 0)
			end if
		end scope
	#endmacro

convert c:
	#define g_assert_error(err, dom, c) \
		G_STMT_START { \
			if (!err || (err)->domain != dom || (err)->code != c) \
				g_assertion_message_error(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #err, err, dom, c); \
		} G_STMT_END
to fb:
	#macro g_assert_error(err, dom, c)
		scope
			if err = 0 orelse (err)->domain <> dom orelse (err)->code <> c then
				g_assertion_message_error(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #err, err, dom, c)
			end if
		end scope
	#endmacro

convert c:
	#define g_assert_true(expr) \
		G_STMT_START { \
			if G_LIKELY(expr) \
				; \
			else \
				g_assertion_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, "'" #expr "' should be TRUE"); \
		} G_STMT_END
to fb:
	#macro g_assert_true(expr)
		scope
			if G_LIKELY(expr) then
			else
				g_assertion_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, "'" #expr "' should be TRUE")
			end if
		end scope
	#endmacro

convert c:
	#define g_assert_false(expr) \
		G_STMT_START { \
			if G_LIKELY(!(expr)) \
				; \
			else \
				g_assertion_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, "'" #expr "' should be FALSE"); \
		} G_STMT_END
to fb:
	#macro g_assert_false(expr)
		scope
			if G_LIKELY((expr) = 0) then
			else
				g_assertion_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, "'" #expr "' should be FALSE")
			end if
		end scope
	#endmacro

convert c:
	#define g_assert_null(expr) \
		G_STMT_START { \
			if G_LIKELY((expr) == NULL) \
				; \
			else \
				g_assertion_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, "'" #expr "' should be NULL"); \
		} G_STMT_END
to fb:
	#macro g_assert_null(expr)
		scope
			if G_LIKELY((expr) = NULL) then
			else
				g_assertion_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, "'" #expr "' should be NULL")
			end if
		end scope
	#endmacro

convert c:
	#define g_assert_nonnull(expr) \
		G_STMT_START { \
			if G_LIKELY((expr) != NULL) \
				; \
			else \
				g_assertion_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, "'" #expr "' should not be NULL"); \
		} G_STMT_END
to fb:
	#macro g_assert_nonnull(expr)
		scope
			if G_LIKELY((expr) <> NULL) then
			else
				g_assertion_message(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, "'" #expr "' should not be NULL")
			end if
		end scope
	#endmacro

convert c: #define g_assert_not_reached() G_STMT_START { g_assertion_message_expr(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, NULL); } G_STMT_END
to c:      #define g_assert_not_reached()                g_assertion_message_expr(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, NULL)

convert c:
	#define g_assert(expr) \
		G_STMT_START { \
			if G_LIKELY(expr) \
				; \
			else \
				g_assertion_message_expr(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #expr); \
		} G_STMT_END
to fb:
	#macro g_assert(expr)
		scope
			if G_LIKELY(expr) then
			else
				g_assertion_message_expr(G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, #expr)
			end if
		end scope
	#endmacro

convert c:
	#define g_test_add(testpath, Fixture, tdata, fsetup, ftest, fteardown) \
		G_STMT_START { \
			void (*add_vtable)( \
				const char*, \
				gsize, \
				gconstpointer, \
				void (*)(Fixture*, gconstpointer), \
				void (*)(Fixture*, gconstpointer), \
				void (*)(Fixture*, gconstpointer) \
			) = (void (*)( \
				const gchar *, \
				gsize, \
				gconstpointer, \
				void (*)(Fixture*, gconstpointer), \
				void (*)(Fixture*, gconstpointer), \
				void (*)(Fixture*, gconstpointer) \
			)) g_test_add_vtable; \
			add_vtable(testpath, sizeof (Fixture), tdata, fsetup, ftest, fteardown); \
		} G_STMT_END
to fb:
	#macro g_test_add(testpath, Fixture, tdata, fsetup, ftest, fteardown)
		scope
			dim add_vtable as sub cdecl( _
				byval as const zstring ptr, _
				byval as gsize, _
				byval as gconstpointer, _
				byval as sub cdecl(byval as Fixture ptr, byval as gconstpointer), _
				byval as sub cdecl(byval as Fixture ptr, byval as gconstpointer), _
				byval as sub cdecl(byval as Fixture ptr, byval as gconstpointer) _
			) = cast(sub cdecl( _
				byval as const zstring ptr, _
				byval as gsize, _
				byval as gconstpointer, _
				byval as sub cdecl(byval as Fixture ptr, byval as gconstpointer), _
				byval as sub cdecl(byval as Fixture ptr, byval as gconstpointer), _
				byval as sub cdecl(byval as Fixture ptr, byval as gconstpointer) _
			), g_test_add_vtable)
			add_vtable(testpath, sizeof(Fixture), tdata, fsetup, ftest, fteardown)
		end scope
	#endmacro
